{"version":3,"file":"noautolink.min.js","sources":["../src/noautolink.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Helper for Tiny noautolink plugin.\n *\n * @module      tiny_noautolink/noautolink\n * @copyright   2023 Meirza <meirza.arson@moodle.com>\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Pending from 'core/pending';\n\nconst noautolinkClassName = 'nolink';\nconst noautolinkTagHTML = 'span';\nconst notificationTimeout = 2000;\n\n/**\n * Handle action.\n *\n * @param {TinyMCE} editor\n * @param {object} messages\n * @param {String} messages.errorInvalidURL\n * @param {String} messages.infoEmptySelection\n */\nexport const handleAction = (editor, messages) => {\n    const selection = editor.selection;\n    const toggleState = isInAnchor(editor, selection.getNode());\n\n    const urlString = getSelectedContent(editor);\n\n    if (urlString !== '' && !toggleState) {\n        // Check whether the string is a URL. Otherwise, show an error notification.\n        if (isValidUrl(urlString)) {\n            const pendingPromise = new Pending('tiny_noautolink/setNoautolink');\n            // Add the link.\n            setNoautolinkOnSelection(editor, urlString)\n            .then(pendingPromise.resolve)\n            .catch(error => {\n                editor.notificationManager.open({text: error, type: 'error', timeout: notificationTimeout});\n                pendingPromise.reject(error); // Handle the error as needed\n            })\n            .finally(() => {\n                editor.notificationManager.open({text: messages.infoAddSuccess, type: 'success', timeout: notificationTimeout});\n            });\n        } else {\n            editor.notificationManager.open({text: messages.errorInvalidURL, type: 'error', timeout: notificationTimeout});\n        }\n    } else if (toggleState) {\n        const nodeString = selection.getNode().outerHTML.trim();\n\n        // Convert HTML string to DOM element to get nolink class.\n        const wrapper = document.createElement('div');\n        wrapper.innerHTML = nodeString;\n        const tempElement = wrapper.firstChild;\n        if (tempElement.classList.contains('nolink')) {\n            const pendingPromise = new Pending('tiny_noautolink/setNoautolink');\n            // Remove the link.\n            unsetNoautolinkOnSelection(editor, nodeString)\n            .then(pendingPromise.resolve)\n            .catch(error => {\n                editor.notificationManager.open({text: error, type: 'error', timeout: notificationTimeout});\n                pendingPromise.reject(error); // Handle the error as needed.\n            })\n            .finally(() => {\n                editor.notificationManager.open({text: messages.infoRemoveSuccess, type: 'success', timeout: notificationTimeout});\n            });\n        }\n    } else {\n        editor.notificationManager.open({text: messages.infoEmptySelection, type: 'info', timeout: notificationTimeout});\n    }\n};\n\n/**\n * Get selected content\n *\n * @param {TinyMCE} editor\n * @returns {String}\n */\nconst getSelectedContent = (editor) => {\n    const selection = editor.selection; // Get the selection object.\n    let urlString = selection.getContent({format: 'text'}).trim();\n    if (urlString == '') {\n        const range = selection.getRng(); // Get the range object.\n\n        // Check if the cursor is within a text node.\n        if (range.startContainer.nodeType === Node.TEXT_NODE) {\n            const textContent = range.startContainer.textContent;\n            const cursorOffset = range.startOffset;\n\n            // Find the word boundaries around the cursor.\n            let wordStart = cursorOffset;\n            while (wordStart > 0 && /\\S/.test(textContent[wordStart - 1])) {\n                wordStart--;\n            }\n\n            let wordEnd = cursorOffset;\n            while (wordEnd < textContent.length && /\\S/.test(textContent[wordEnd])) {\n                wordEnd++;\n            }\n\n            // Set the selection range to the word.\n            selection.setRng({\n                startContainer: range.startContainer,\n                startOffset: wordStart,\n                endContainer: range.startContainer,\n                endOffset: wordEnd,\n            });\n            urlString = selection.getContent({format: 'text'}).trim();\n        }\n    }\n    return urlString;\n};\n\n/**\n * Wrap the selection with the nolink class.\n *\n * @param {TinyMCE} editor\n * @param {String} url URL the link will point to.\n */\nconst setNoautolinkOnSelection = async(editor, url) => {\n    const newContent = `<${noautolinkTagHTML} class=\"${noautolinkClassName}\">${url}</${noautolinkTagHTML}>`;\n    editor.selection.setContent(newContent);\n\n    // Select the new content.\n    const currentNode = editor.selection.getNode();\n    const currentDOM = editor.dom.select(`${noautolinkTagHTML}.${noautolinkClassName}`, currentNode);\n    currentDOM.forEach(function(value, index) {\n        if (value.outerHTML == newContent) {\n            editor.selection.select(currentDOM[index]);\n            return;\n        }\n    });\n};\n\n/**\n * Remove the nolink on the selection.\n *\n * @param {TinyMCE} editor\n * @param {String} url URL the link will point to.\n */\nconst unsetNoautolinkOnSelection = async(editor, url) => {\n    const regex = new RegExp(`</?${noautolinkTagHTML}[^>]*>`, \"g\");\n    url = url.replace(regex, \"\");\n    const currentSpan = editor.dom.getParent(editor.selection.getNode(), noautolinkTagHTML);\n    currentSpan.outerHTML = url;\n};\n\n/**\n * Check if given string is a valid URL.\n *\n * @param {String} urlString URL the link will point to.\n * @returns {boolean} True is valid, otherwise false.\n */\nconst isValidUrl = urlString => {\n    const urlPattern = new RegExp('^((http|https):\\\\/\\\\/|www\\\\.)' + // A URL must have on of these https/https/www.\n                                '((([a-z\\\\d]([a-z\\\\d-]*[a-z\\\\d])*)\\\\.)+[a-z]{2,}|' + // Validate domain name.\n                                '((\\\\d{1,3}\\\\.){3}\\\\d{1,3}))' + // Validate OR ip (v4) address.\n                                '(\\\\:\\\\d+)?(\\\\/[-a-z\\\\d%_.~+]*)*' + // Validate port and path.\n                                '(\\\\?[;&a-z\\\\d%_.~+=-]*)?' + // Validate query string.\n                                '(\\\\#[-a-z\\\\d_]*)?$', 'i'); // Validate fragment locator.\n\n    return !!urlPattern.test(urlString);\n};\n\n/**\n * Get anchor element.\n *\n * @param {TinyMCE} editor\n * @param {Element} selectedElm\n * @returns {Element}\n */\nconst getAnchorElement = (editor, selectedElm) => {\n    selectedElm = selectedElm || editor.selection.getNode();\n    return editor.dom.getParent(selectedElm, `${noautolinkTagHTML}.${noautolinkClassName}`);\n};\n\n\n/**\n * Check the current selected element is an anchor or not.\n *\n * @param {TinyMCE} editor\n * @param {Element} selectedElm\n * @returns {boolean}\n */\nconst isInAnchor = (editor, selectedElm) => getAnchorElement(editor, selectedElm) !== null;\n\n/**\n * Change state of button.\n *\n * @param {TinyMCE} editor\n * @param {function()} toggler\n * @returns {function()}\n */\nconst toggleState = (editor, toggler) => {\n    editor.on('NodeChange', toggler);\n    return () => editor.off('NodeChange', toggler);\n};\n\n/**\n * Change the active state of button.\n *\n * @param {TinyMCE} editor\n * @returns {function(*): function(): *}\n */\nexport const toggleActiveState = (editor) => (api) => {\n    const updateState = () => api.setActive(!editor.mode.isReadOnly() && isInAnchor(editor, editor.selection.getNode()));\n    updateState();\n    return toggleState(editor, updateState);\n};"],"names":["editor","messages","selection","toggleState","isInAnchor","getNode","urlString","getSelectedContent","nodeString","outerHTML","trim","wrapper","document","createElement","innerHTML","firstChild","classList","contains","pendingPromise","Pending","unsetNoautolinkOnSelection","then","resolve","catch","error","notificationManager","open","text","type","timeout","reject","finally","infoRemoveSuccess","infoEmptySelection","isValidUrl","setNoautolinkOnSelection","infoAddSuccess","errorInvalidURL","getContent","format","range","getRng","startContainer","nodeType","Node","TEXT_NODE","textContent","cursorOffset","startOffset","wordStart","test","wordEnd","length","setRng","endContainer","endOffset","async","url","newContent","setContent","currentNode","currentDOM","dom","select","forEach","value","index","regex","RegExp","replace","getParent","selectedElm","getAnchorElement","api","updateState","setActive","mode","isReadOnly","toggler","on","off"],"mappings":"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"}