{"version":3,"file":"noautolink.min.js","sources":["../src/noautolink.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Helper for Tiny noautolink plugin.\n *\n * @module      tiny_noautolink/noautolink\n * @copyright   2023 Meirza <meirza.arson@moodle.com>\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Pending from 'core/pending';\n\nconst noautolinkClassName = 'nolink';\nconst noautolinkTagHTML = 'span';\n\n/**\n * Handle action.\n *\n * @param {TinyMCE} editor\n * @param {String} errorMsg\n * @param {String} infoMsg\n */\nexport const handleAction = (editor, errorMsg, infoMsg) => {\n    const toggleState = isInAnchor(editor, editor.selection.getNode());\n    let urlString = editor.selection.getContent({format: 'text'}).trim();\n    if (urlString !== '' && !toggleState) {\n        // Check whether the string is an URL. Otherwise, show an error notification.\n        if (isValidUrl(urlString)) {\n            const pendingPromise = new Pending('tiny_noautolink/setNoautolink');\n            // Add the link.\n            setNoautolinkOnSelection(editor, urlString).then(pendingPromise.resolve);\n        } else {\n            editor.notificationManager.open({\n                text: errorMsg,\n                type: 'error',\n                timeout: 3000\n            });\n        }\n    } else if (toggleState) {\n        const nodeString = editor.selection.getNode().outerHTML.trim();\n\n        // Convert HTML string to DOM element to get nolink class.\n        const wrapper = document.createElement('div');\n        wrapper.innerHTML = nodeString;\n        const tempElement = wrapper.firstChild;\n        if (tempElement.classList.contains('nolink')) {\n            const pendingPromise = new Pending('tiny_noautolink/setNoautolink');\n            // Remove the link.\n            unsetNoautolinkOnSelection(editor, nodeString).then(pendingPromise.resolve);\n        }\n    } else {\n        editor.notificationManager.open({\n            text: infoMsg,\n            type: 'info',\n            timeout: 5000\n        });\n    }\n};\n\n/**\n * Set new content on the selection.\n *\n * @param {TinyMCE} editor\n * @param {String} url URL the link will point to.\n */\nconst setNoautolinkOnSelection = async(editor, url) => {\n    const newContent = `<${noautolinkTagHTML} class=\"${noautolinkClassName}\">${url}</${noautolinkTagHTML}>`;\n    editor.selection.setContent(newContent);\n\n    // Highlight the new content.\n    const currentNode = editor.selection.getNode();\n    const currentDOM = editor.dom.select(`${noautolinkTagHTML}.${noautolinkClassName}`, currentNode);\n    currentDOM.forEach(function(value, index) {\n        if (value.outerHTML == newContent) {\n            editor.selection.select(currentDOM[index]);\n            return;\n        }\n    });\n};\n\n/**\n * Remove the nolink on the selection.\n *\n * @param {TinyMCE} editor\n * @param {String} url URL the link will point to.\n */\nconst unsetNoautolinkOnSelection = async(editor, url) => {\n    const regex = new RegExp(`</?${noautolinkTagHTML}[^>]*>`, \"g\");\n    url = url.replace(regex, \"\");\n    const currentSpan = editor.dom.getParent(editor.selection.getNode(), noautolinkTagHTML);\n    currentSpan.outerHTML = url;\n};\n\n/**\n * Check if given string is a valid URL.\n *\n * @param {String} urlString URL the link will point to.\n * @returns {boolean} True is valid, otherwise false.\n */\nconst isValidUrl = urlString => {\n    const urlPattern = new RegExp('^(https?:\\\\/\\\\/)?' + // Validate protocol\n                                '((([a-z\\\\d]([a-z\\\\d-]*[a-z\\\\d])*)\\\\.)+[a-z]{2,}|' + // Validate domain name\n                                '((\\\\d{1,3}\\\\.){3}\\\\d{1,3}))' + // Validate OR ip (v4) address\n                                '(\\\\:\\\\d+)?(\\\\/[-a-z\\\\d%_.~+]*)*' + // Validate port and path\n                                '(\\\\?[;&a-z\\\\d%_.~+=-]*)?' + // Validate query string\n                                '(\\\\#[-a-z\\\\d_]*)?$', 'i'); // Validate fragment locator\n    return !!urlPattern.test(urlString);\n};\n\n/**\n * Get anchor element.\n *\n * @param {TinyMCE} editor\n * @param {Element} selectedElm\n * @returns {Element}\n */\nconst getAnchorElement = (editor, selectedElm) => {\n    selectedElm = selectedElm || editor.selection.getNode();\n    return editor.dom.getParent(selectedElm, `${noautolinkTagHTML}.${noautolinkClassName}`);\n};\n\n\n/**\n * Check the current selected element is an anchor or not.\n *\n * @param {TinyMCE} editor\n * @param {Element} selectedElm\n * @returns {boolean}\n */\nconst isInAnchor = (editor, selectedElm) => getAnchorElement(editor, selectedElm) !== null;\n\n/**\n * Change state of button.\n *\n * @param {TinyMCE} editor\n * @param {function()} toggler\n * @returns {function()}\n */\nconst toggleState = (editor, toggler) => {\n    editor.on('NodeChange', toggler);\n    return () => editor.off('NodeChange', toggler);\n};\n\n/**\n * Change the active state of button.\n *\n * @param {TinyMCE} editor\n * @returns {function(*): function(): *}\n */\nexport const toggleActiveState = (editor) => (api) => {\n    const updateState = () => api.setActive(!editor.mode.isReadOnly() && isInAnchor(editor, editor.selection.getNode()));\n    updateState();\n    return toggleState(editor, updateState);\n};"],"names":["editor","errorMsg","infoMsg","toggleState","isInAnchor","selection","getNode","urlString","getContent","format","trim","nodeString","outerHTML","wrapper","document","createElement","innerHTML","firstChild","classList","contains","pendingPromise","Pending","unsetNoautolinkOnSelection","then","resolve","notificationManager","open","text","type","timeout","isValidUrl","setNoautolinkOnSelection","async","url","newContent","setContent","currentNode","currentDOM","dom","select","forEach","value","index","regex","RegExp","replace","getParent","test","selectedElm","getAnchorElement","api","updateState","setActive","mode","isReadOnly","toggler","on","off"],"mappings":";;;;;;;qMAmC4B,CAACA,OAAQC,SAAUC,iBACrCC,YAAcC,WAAWJ,OAAQA,OAAOK,UAAUC,eACpDC,UAAYP,OAAOK,UAAUG,WAAW,CAACC,OAAQ,SAASC,UAC5C,KAAdH,WAAqBJ,YAalB,GAAIA,YAAa,OACdQ,WAAaX,OAAOK,UAAUC,UAAUM,UAAUF,OAGlDG,QAAUC,SAASC,cAAc,OACvCF,QAAQG,UAAYL,cACAE,QAAQI,WACZC,UAAUC,SAAS,UAAW,OACpCC,eAAiB,IAAIC,iBAAQ,iCAEnCC,2BAA2BtB,OAAQW,YAAYY,KAAKH,eAAeI,eAGvExB,OAAOyB,oBAAoBC,KAAK,CAC5BC,KAAMzB,QACN0B,KAAM,OACNC,QAAS,cA3BTC,WAAWvB,WAAY,OACjBa,eAAiB,IAAIC,iBAAQ,iCAEnCU,yBAAyB/B,OAAQO,WAAWgB,KAAKH,eAAeI,cAEhExB,OAAOyB,oBAAoBC,KAAK,CAC5BC,KAAM1B,SACN2B,KAAM,QACNC,QAAS,aA8BnBE,yBAA2BC,MAAMhC,OAAQiC,aACrCC,sBArDgB,0BADE,sBAsDmDD,iBArDrD,YAsDtBjC,OAAOK,UAAU8B,WAAWD,kBAGtBE,YAAcpC,OAAOK,UAAUC,UAC/B+B,WAAarC,OAAOsC,IAAIC,iBA1DR,mBADE,UA2D4DH,aACpFC,WAAWG,SAAQ,SAASC,MAAOC,OAC3BD,MAAM7B,WAAasB,YACnBlC,OAAOK,UAAUkC,OAAOF,WAAWK,YAYzCpB,2BAA6BU,MAAMhC,OAAQiC,aACvCU,MAAQ,IAAIC,oBA1EI,iBA0EoC,KAC1DX,IAAMA,IAAIY,QAAQF,MAAO,IACL3C,OAAOsC,IAAIQ,UAAU9C,OAAOK,UAAUC,UA5EpC,QA6EVM,UAAYqB,KAStBH,WAAavB,aACI,IAAIqC,OAAO,wKAKoB,KAC9BG,KAAKxC,WAuBvBH,WAAa,CAACJ,OAAQgD,cAA0D,OAb7D,EAAChD,OAAQgD,eAC9BA,YAAcA,aAAehD,OAAOK,UAAUC,UACvCN,OAAOsC,IAAIQ,UAAUE,sBAzGN,mBADE,YAqHgBC,CAAiBjD,OAAQgD,wCAoBnChD,QAAYkD,YACpCC,YAAc,IAAMD,IAAIE,WAAWpD,OAAOqD,KAAKC,cAAgBlD,WAAWJ,OAAQA,OAAOK,UAAUC,mBACzG6C,cAbgB,EAACnD,OAAQuD,WACzBvD,OAAOwD,GAAG,aAAcD,SACjB,IAAMvD,OAAOyD,IAAI,aAAcF,UAY/BpD,CAAYH,OAAQmD"}