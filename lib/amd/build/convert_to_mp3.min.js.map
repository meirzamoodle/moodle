{"version":3,"file":"convert_to_mp3.min.js","sources":["../src/convert_to_mp3.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Convert audio to MP3.\n *\n * @module     core/convert_to_mp3\n * @copyright  Meirza <meirza.arson@moodle.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n/**\n * Loads the lamejs script dynamically by appending a script tag to the document.\n *\n * @param {string} url - The URL of the lamejs script to be loaded.\n * @returns {Promise} - A promise that resolves with the global lamejs object once the script is loaded.\n */\nconst loadLamejs = (url) => {\n    return new Promise((resolve, reject) => {\n        const script = document.createElement('script');\n        script.src = url;\n        script.onload = () => {\n            if (typeof window.lamejs !== 'undefined') {\n                resolve(window.lamejs); // Return the global Lame object.\n            } else {\n                reject(new Error('Lame is not defined'));\n            }\n        };\n        script.onerror = () => reject(new Error(`Failed to load script: ${url}`));\n        document.head.appendChild(script);\n    });\n};\n\n/**\n * Loads the lamejs module.\n *\n * The original file is a non-ESM library,\n * so it is loaded this way to avoid modifying the original file.\n *\n * @returns {Promise} - A promise that resolves with the loaded lamejs module.\n */\nconst loadLamejsModule = async() => {\n    return await loadLamejs(`${M.cfg.wwwroot}/lib/lamejs/lame.min.js`);\n};\n\n/**\n * Extract Pulse Code Modulation (PCM) data from an AudioBuffer to get raw channel data.\n *\n * @param {AudioBuffer} audioBuffer The AudioBuffer containing the audio data.\n * @returns {Array<Int16Array>} The PCM data for each channel.\n */\nconst extractPCM = (audioBuffer) => {\n    const channelData = [];\n    const numberOfChannels = audioBuffer.numberOfChannels;\n    const audioBufferLength = audioBuffer.length;\n\n    for (let channel = 0; channel < numberOfChannels; channel++) {\n        const rawChannelData = audioBuffer.getChannelData(channel);\n        channelData[channel] = new Int16Array(audioBufferLength);\n        // Convert floating-point audio samples into 16-bit signed integer values.\n        for (let i = 0; i < audioBufferLength; i++) {\n            channelData[channel][i] = rawChannelData[i] * 32768;\n        }\n    }\n\n    return channelData;\n};\n\n/**\n * Fetches and decodes the audio data from a given URL into an AudioBuffer.\n *\n * @param {string} sourceUrl - The URL of the source audio file.\n * @returns {Promise<AudioBuffer>} - A promise that resolves with the decoded AudioBuffer object.\n */\nconst getAudioBuffer = async(sourceUrl) => {\n    const response = await fetch(sourceUrl);\n    const arrayBuffer = await response.arrayBuffer();\n    const audioContext = new (\n        window.AudioContext // Default.\n        || window.webkitAudioContext // Safari and old versions of Chrome.\n    )();\n    return audioContext.decodeAudioData(arrayBuffer);\n};\n\n/**\n * Converts an AudioBuffer to MP3 format using lamejs.\n *\n * @param {Object} lamejs - The lamejs library object.\n * @param {number} channels - The number of audio channels (1 for mono, 2 for stereo).\n * @param {number} sampleRate - The sample rate of the audio (e.g., 44100 Hz).\n * @param {number} bitRate - The bitrate (in kbps) to encode the MP3.\n * @param {Int16Array} left - The PCM data for the left channel.\n * @param {Int16Array} [right=null] - The PCM data for the right channel (optional for stereo).\n * @returns {Blob} - A Blob containing the MP3 audio data.\n */\nconst convertAudioBuffer = (lamejs, channels, sampleRate, bitRate, left, right = null) => {\n    const mp3Data = [];\n    const mp3Encoder = new lamejs.Mp3Encoder(channels, sampleRate, bitRate);\n    // Each frame represents 1152 audio samples per channel (for both mono and stereo).\n    const sampleBlockSize = 1152;\n\n    // Ensure that the same encoding logic works for both mono and stereo audio by\n    // either passing both channels or just the left channel to the MP3 encoder.\n    for (let i = 0; i < left.length; i += sampleBlockSize) {\n        const leftChunk = left.subarray(i, i + sampleBlockSize);\n        const mp3Buf = right\n            ? mp3Encoder.encodeBuffer(leftChunk, right.subarray(i, i + sampleBlockSize)) // Stereo.\n            : mp3Encoder.encodeBuffer(leftChunk); // Mono.\n\n        if (mp3Buf.length) {\n            mp3Data.push(mp3Buf);\n        }\n    }\n\n    // Preventing loss of the last few samples of audio.\n    const mp3Buf = mp3Encoder.flush();\n    if (mp3Buf.length) {\n        mp3Data.push(new Int8Array(mp3Buf));\n    }\n\n    return new Blob(mp3Data, {type: 'audio/mp3'});\n};\n\n/**\n * Main function to handle the entire process of converting an audio file to MP3 format.\n *\n * @param {string} sourceUrl - The URL of the source audio file to be converted.\n * @param {number} [bitRate=128] - The bitrate (in kbps) for the MP3 conversion. Default is 128 kbps.\n * @returns {Promise<Blob>} - A promise that resolves with the MP3 file as a Blob.\n *\n * @throws {Error} If the Lamejs module or audio buffer fails to load.\n *\n * @example\n * const mp3Data = await convertMp3('audio-source.wav', 192);\n * window.console.log(mp3Data); // Logs the ArrayBuffer with MP3 data.\n */\nexport const convertMp3 = async(sourceUrl, bitRate = 128) => {\n    const lamejs = await loadLamejsModule();\n    const audioBuffer = await getAudioBuffer(sourceUrl);\n    const [left, right] = extractPCM(audioBuffer);\n    return convertAudioBuffer(lamejs, audioBuffer.numberOfChannels, audioBuffer.sampleRate, bitRate, left, right);\n};\n"],"names":["loadLamejsModule","async","url","M","cfg","wwwroot","Promise","resolve","reject","script","document","createElement","src","onload","window","lamejs","Error","onerror","head","appendChild","extractPCM","audioBuffer","channelData","numberOfChannels","audioBufferLength","length","channel","rawChannelData","getChannelData","Int16Array","i","getAudioBuffer","response","fetch","sourceUrl","arrayBuffer","AudioContext","webkitAudioContext","decodeAudioData","convertAudioBuffer","channels","sampleRate","bitRate","left","right","mp3Data","mp3Encoder","Mp3Encoder","sampleBlockSize","leftChunk","subarray","mp3Buf","encodeBuffer","push","flush","Int8Array","Blob","type"],"mappings":";;;;;;;;MAqDMA,iBAAmBC,uBAxBLC,cAyBWC,EAAEC,IAAIC,mCAxB1B,IAAIC,SAAQ,CAACC,QAASC,gBACnBC,OAASC,SAASC,cAAc,UACtCF,OAAOG,IAAMV,IACbO,OAAOI,OAAS,UACiB,IAAlBC,OAAOC,OACdR,QAAQO,OAAOC,QAEfP,OAAO,IAAIQ,MAAM,yBAGzBP,OAAOQ,QAAU,IAAMT,OAAO,IAAIQ,uCAAgCd,OAClEQ,SAASQ,KAAKC,YAAYV,YAZdP,IAAAA,KAkCdkB,WAAcC,oBACVC,YAAc,GACdC,iBAAmBF,YAAYE,iBAC/BC,kBAAoBH,YAAYI,WAEjC,IAAIC,QAAU,EAAGA,QAAUH,iBAAkBG,UAAW,OACnDC,eAAiBN,YAAYO,eAAeF,SAClDJ,YAAYI,SAAW,IAAIG,WAAWL,uBAEjC,IAAIM,EAAI,EAAGA,EAAIN,kBAAmBM,IACnCR,YAAYI,SAASI,GAAyB,MAApBH,eAAeG,UAI1CR,aASLS,eAAiB9B,MAAAA,kBACb+B,eAAiBC,MAAMC,WACvBC,kBAAoBH,SAASG,qBACd,IACjBrB,OAAOsB,cACJtB,OAAOuB,qBAEMC,gBAAgBH,cAclCI,mBAAqB,SAACxB,OAAQyB,SAAUC,WAAYC,QAASC,UAAMC,6DAAQ,WACvEC,QAAU,GACVC,WAAa,IAAI/B,OAAOgC,WAAWP,SAAUC,WAAYC,SAEzDM,gBAAkB,SAInB,IAAIlB,EAAI,EAAGA,EAAIa,KAAKlB,OAAQK,GAAKkB,gBAAiB,OAC7CC,UAAYN,KAAKO,SAASpB,EAAGA,EAAIkB,iBACjCG,OAASP,MACTE,WAAWM,aAAaH,UAAWL,MAAMM,SAASpB,EAAGA,EAAIkB,kBACzDF,WAAWM,aAAaH,WAE1BE,OAAO1B,QACPoB,QAAQQ,KAAKF,cAKfA,OAASL,WAAWQ,eACtBH,OAAO1B,QACPoB,QAAQQ,KAAK,IAAIE,UAAUJ,SAGxB,IAAIK,KAAKX,QAAS,CAACY,KAAM,mCAgBVxD,eAAMiC,eAAWQ,+DAAU,UAC3C3B,aAAef,mBACfqB,kBAAoBU,eAAeG,YAClCS,KAAMC,OAASxB,WAAWC,oBAC1BkB,mBAAmBxB,OAAQM,YAAYE,iBAAkBF,YAAYoB,WAAYC,QAASC,KAAMC"}